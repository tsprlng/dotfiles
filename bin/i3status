#!/usr/bin/env ruby

require 'date'
require 'dbus'
require 'json'

dbus_events, dbus_event_sender = IO.pipe
dbus_watcher = fork do
	$0 = 'i3status (dbus watcher)'
	dbus_events.close  # this end is for the parent to use to receive from us

	#session_bus = DBus.session_bus
	#pa_sock_addr = session_bus['org.PulseAudio1']['/org/pulseaudio/server_lookup1']['org.PulseAudio.ServerLookup1']['Address']
	#TODO why is org.PulseAudio1 missing sometimes on session start?
	pa_sock_addr = "unix:path=/run/user/#{Process.uid}/pulse/dbus-socket"

	retried = false
	begin
		pa_bus = DBus::Connection.new(pa_sock_addr)
	rescue
		raise if retried
		retried = true
		$stderr.puts 'Loading pulseaudio dbus module'
		`pactl load-module module-dbus-protocol`
		sleep 1
		retry
	end
	core = pa_bus['org.PulseAudio1.Core1']['/org/pulseaudio/core1']
	core.default_iface = 'org.PulseAudio.Core1'

	core.ListenForSignal('org.PulseAudio.Core1.Device.MuteUpdated', [])
	core.ListenForSignal('org.PulseAudio.Core1.Device.VolumeUpdated', [])

	match_rule = DBus::MatchRule.new
	match_rule.interface = 'org.PulseAudio.Core1.Device'
	match_rule.member = 'MuteUpdated'
	pa_bus.add_match(match_rule) do |state|
		dbus_event_sender.puts 'mute' if state.path.include? 'sink'
	end

	match_rule = DBus::MatchRule.new
	match_rule.interface = 'org.PulseAudio.Core1.Device'
	match_rule.member = 'VolumeUpdated'
	pa_bus.add_match(match_rule) do |state|
		dbus_event_sender.puts 'volume' if state.path.include? 'sink'
	end

	loop = DBus::Main.new
	loop << pa_bus
	loop.run
end
at_exit do
	Process.kill('TERM', dbus_watcher) rescue nil
	Process.wait(dbus_watcher)
end
dbus_event_sender.close  # this end is for the child to use to send to us

def get_brightness_percent
	curr = IO.read '/sys/class/backlight/intel_backlight/actual_brightness'
	max = IO.read '/sys/class/backlight/intel_backlight/max_brightness'
	(curr.to_f * 100/ max.to_f).round
end

def get_volume_percent
	`volume show`.chomp  # TODO replace this shit with DBus query
end

def date_pretty
	now = DateTime.now  #.new_offset(0)
	#return DateTime.now.new_offset(0).iso8601.sub '+00:00', 'Z'
	case now.offset
	when 0
		now.strftime '%Y-%m-%d %H:%M:%S'
	else
		now.strftime '%Y-%m-%d "%H:%M:%S"'
	end
end

def get_load_1m
	loads = IO.read '/proc/loadavg'
	loads.split(' ',2)[0]
end

def get_ip(if_name)
	ips = `ip -o -f inet addr show primary up`
	ipline = ips.each_line .find {|l| l.match /^\d+: #{if_name}/}
	(ipline.split(' inet ',2)[1]).split('/',2)[0]
end

def wlan_pretty(if_name)
	ip = get_ip(if_name)
	wstat = IO.read '/proc/net/wireless'
	stats = wstat.each_line .find {|l| l.match /^#{if_name}/} .split /\s+/
	"#{stats[3].chomp('.')}dB #{stats[5..10].map(&:to_i).inject(:+)}! #{ip}"
end

def eth_pretty(if_name)
	get_ip if_name
end

def disk_space
	`df -h /`.lines()[1].split(/\s+/)[3]
end

def memory_space
	lines = IO.read('/proc/meminfo').each_line.to_a
	swap_free = lines.find {|l| l.match /^SwapFree:/ }.split(/\s+/)[1].to_f
	mem_avail = lines.find {|l| l.match /^MemAvailable:/ }.split(/\s+/)[1].to_f
	"#{(mem_avail / 1024 / 1024).round(1)}G #{(swap_free / 1024 / 1024).round(1)}G"
end

def battery_stuff(whichbat, label)
	designed_cap = IO.read("/sys/class/power_supply/#{whichbat}/energy_full_design").chomp.to_f
	actual_cap = IO.read("/sys/class/power_supply/#{whichbat}/energy_full").chomp.to_f
	current = IO.read("/sys/class/power_supply/#{whichbat}/energy_now").chomp.to_f
	status = IO.read("/sys/class/power_supply/#{whichbat}/status").chomp

	percent = (100 * current / designed_cap).round(1)

	color = case
		when percent <= 5 then '#ff0000'
		when (status == 'Full' || status == 'Unknown') && current >= (actual_cap * 0.97) then '#009900'
		when (status == 'Charging' || status == 'Unknown') then '#dddd00'
		else '#999999'
	end

	{ name: :battery, instance: whichbat, color: color, full_text: "#{label} #{percent}" }
end

def get_output_string
	stuff = []
	stuff << { name: :disk_info, instance: '/', color: '#666666', full_text: disk_space }
	stuff << { name: :mem_info, color: '#666666', full_text: memory_space }
	stuff.last.merge!({separator: true})

	stuff << ( { name: :ethernet, instance: 'ppp0', color: '#ffff00', full_text: "VPN: #{eth_pretty 'ppp0'}" } rescue { name: :ethernet, instance: 'ppp0', color: '#444444', full_text: 'VPN: down' } )
	stuff << ( { name: :ethernet, instance: 'enp0s25', color: '#6677cc', full_text: "E: #{eth_pretty 'enp0s25'}" } rescue { name: :ethernet, instance: 'enp0s25', color: '#880000', full_text: 'E: down' } )
	stuff << ( { name: :wireless, instance: 'wlp3s0', color: '#6677cc', full_text: "W: #{wlan_pretty 'wlp3s0'}" } rescue { name: :wireless, instance: 'wlp3s0', color: '#880000', full_text: 'W: down' } )
	stuff.last.merge!({separator: true})

	stuff << battery_stuff('BAT0', 'int')
	stuff << battery_stuff('BAT1', 'ext')
	stuff.last.merge!({separator: true})

	stuff << { name: :load, full_text: get_load_1m }
	stuff.last.merge!({separator: true})

	stuff << { name: :brightness, full_text: "â˜¼ #{get_brightness_percent}%" }
	volicon = case
		when @cached_volume_percent.to_i > 50 then 'ðŸ”Š'
		when @cached_volume_percent.to_i > 0 && !(@cached_volume_percent.include? 'Mute') then 'ðŸ”‰'
		else 'ðŸ”‡'
	end
	stuff << { name: :volume, full_text: "#{volicon} #{@cached_volume_percent.split("\n")[0]}" }
	stuff.last.merge!({separator: true})
	stuff.last.merge!({color: '#dd8800'}) if @cached_volume_percent.include? 'Mute'

	stuff << { name: :tztime, instance: :local, full_text: date_pretty }

	stuff.each do |item|
		if item[:separator]
			item[:separator_block_width] = 27
		else
			item[:separator] = false
			item[:separator_block_width] = 13
		end
	end

	return JSON.generate(stuff)
end

@cached_volume_percent = get_volume_percent

Thread.abort_on_exception = true

redraw = Thread.new do
	$stdout.syswrite "{\"version\":1, \"click_events\":true}\n"
	$stdout.syswrite "[\n"
	first = true
	loop do
		$stdout.syswrite "#{first ? '' : ','}#{get_output_string}\n"
		first = false
		t = Time.now
		sleep (5 - (t.sec + t.subsec) % 5)
	end
end

receive_click_events = Thread.new do
loop do
	begin
		click = $stdin.gets
		click = click[1..-1] if click.start_with? ','
		click = JSON.parse(click)

		if click['button'] == 3 && (click['name'] == 'wireless' || click['name'] == 'ethernet')
			p = Process.spawn("echo #{get_ip click['instance']} | xclip -selection clipboard || true")
			Process.detach(p)
		elsif click['button'] == 3 && click['name'] == 'tztime'
			now = DateTime.now.new_offset(0)
			p = Process.spawn("echo #{now.strftime('%Y-%m-%dT%H:%M:%SZ')} | xclip -selection clipboard || true")
			Process.detach(p)
		end
	rescue
	end
end
end

Signal.trap 'USR1' do
	redraw.run
end

loop do
	ev = dbus_events.gets
	case ev.chomp
		when 'volume', 'mute'
			@cached_volume_percent = get_volume_percent
			redraw.run
	end
end

receive_click_events.join
redraw.join
