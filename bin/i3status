#!/usr/bin/env ruby

require 'date'
require 'dbus'
require 'json'

#session_bus = DBus.session_bus
#pa_sock_addr = session_bus['org.PulseAudio1']['/org/pulseaudio/server_lookup1']['org.PulseAudio.ServerLookup1']['Address']
#TODO why is org.PulseAudio1 missing sometimes on session start?
pa_sock_addr = "unix:path=/run/user/#{Process.uid}/pulse/dbus-socket"

retried = false
begin
	@pa_bus = DBus::Connection.new(pa_sock_addr)
rescue
	raise if retried
	retried = true
	$stderr.puts 'Loading pulseaudio dbus module'
	`pactl load-module module-dbus-protocol`
	sleep 1
	retry
end
@pa_core = @pa_bus['org.PulseAudio1.Core1']['/org/pulseaudio/core1']
@pa_core.default_iface = 'org.PulseAudio.Core1'

dbus_events, dbus_event_sender = IO.pipe
dbus_watcher = fork do
	$0 = 'i3status (dbus watcher)'
	dbus_events.close  # this end is for the parent to use to receive from us

	pa_bus = DBus::Connection.new(pa_sock_addr)
	core = pa_bus['org.PulseAudio1.Core1']['/org/pulseaudio/core1']
	core.default_iface = 'org.PulseAudio.Core1'

	core.ListenForSignal('org.PulseAudio.Core1.Device.MuteUpdated', [])
	core.ListenForSignal('org.PulseAudio.Core1.Device.VolumeUpdated', [])

	match_rule = DBus::MatchRule.new
	match_rule.interface = 'org.PulseAudio.Core1.Device'
	match_rule.member = 'MuteUpdated'
	pa_bus.add_match(match_rule) do |state|
		dbus_event_sender.puts 'mute' if state.path.include? 'sink'
	end

	match_rule = DBus::MatchRule.new
	match_rule.interface = 'org.PulseAudio.Core1.Device'
	match_rule.member = 'VolumeUpdated'
	pa_bus.add_match(match_rule) do |state|
		dbus_event_sender.puts 'volume' if state.path.include? 'sink'
	end

	loop = DBus::Main.new
	loop << pa_bus
	loop.run
end
at_exit do
	Process.kill('TERM', dbus_watcher) rescue nil
	Process.wait(dbus_watcher)
end
dbus_event_sender.close  # this end is for the child to use to send to us

def get_brightness_percent
	curr = IO.read '/sys/class/backlight/intel_backlight/actual_brightness'
	max = IO.read '/sys/class/backlight/intel_backlight/max_brightness'
	(curr.to_f * 100/ max.to_f).round
end

def get_volume_percent
	sink = @pa_core['org.PulseAudio.Core1'].GetSinkByName('@DEFAULT_SINK@')
	sink = @pa_bus['org.PulseAudio1.Core1'][sink]['org.PulseAudio.Core1.Device']
	port = sink['ActivePort'] rescue nil
	port = @pa_bus['org.PulseAudio1.Core1'][port]['org.PulseAudio.Core1.DevicePort'] rescue nil
	return (sink['Volume'].max.to_f * 100 / sink['BaseVolume']).round(0).to_s + '%' + "\n" + (sink['Mute'] ? 'Mute' : '') + "\n" + (port['Description'] rescue '')
end

def date_pretty
	now = DateTime.now  #.new_offset(0)
	#return DateTime.now.new_offset(0).iso8601.sub '+00:00', 'Z'
	case now.offset
	when 0
		now.strftime '%Y-%m-%d %H:%M:%S'
	else
		now.strftime '%Y-%m-%d "%H:%M:%S"'
	end
end

def get_load_1m
	loads = IO.read '/proc/loadavg'
	loads.split(' ',2)[0]
end

def get_ip(if_name)
	ips = `ip -o -f inet addr show primary up`
	ipline = ips.each_line .find {|l| l.match /^\d+: #{if_name}/}
	(ipline.split(' inet ',2)[1]).split('/',2)[0]
end

def wlan_pretty(if_name)
	return 'off' if `rfkill list wifi`.include? 'yes'
	ip = get_ip(if_name)
	wstat = IO.read '/proc/net/wireless'
	stats = wstat.each_line .find {|l| l.match /^#{if_name}/} .split /\s+/
	"#{stats[3].chomp('.')}dB #{stats[5..10].map(&:to_i).inject(:+)}! #{ip}"
end

def eth_pretty(if_name)
	get_ip if_name
end

def disk_space
	`df -h /`.lines()[1].split(/\s+/)[3]
end

def memory_space
	lines = IO.read('/proc/meminfo').each_line.to_a
	swap_free = lines.find {|l| l.match /^SwapFree:/ }.split(/\s+/)[1].to_f
	mem_avail = lines.find {|l| l.match /^MemAvailable:/ }.split(/\s+/)[1].to_f
	"#{(mem_avail / 1024 / 1024).round(1)}G #{(swap_free / 1024 / 1024).round(1)}G"
end

def battery_stuff(whichbat, label)
	begin
		designed_cap = IO.read("/sys/class/power_supply/#{whichbat}/energy_full_design").chomp.to_f
		actual_cap = IO.read("/sys/class/power_supply/#{whichbat}/energy_full").chomp.to_f
		current = IO.read("/sys/class/power_supply/#{whichbat}/energy_now").chomp.to_f
		status = IO.read("/sys/class/power_supply/#{whichbat}/status").chomp

		percent = (100 * current / designed_cap).round(1)

		color = case
			when (status == 'Charging' || status == 'Unknown') then '#dddd00'
			when percent <= 5 then '#ff0000'
			when (status == 'Full' || status == 'Unknown') && current >= (actual_cap * 0.97) then '#009900'
			else '#999999'
		end

		{ name: :battery, instance: whichbat, color: color, full_text: "#{label} #{percent}" }
	rescue
		{ name: :battery, instance: whichbat, color: '#ff0000', full_text: "#{label} X" }
	end
end

def battery_summary
	bats = ['/sys/class/power_supply/BAT0', '/sys/class/power_supply/BAT1']
	ac = IO.read('/sys/class/power_supply/AC/online').to_i != 0
	energy = bats.map {|b| IO.read("#{b}/energy_now").to_i }.inject(:+).to_f
	power = bats.map {|b| IO.read("#{b}/power_now").to_i }.inject(:+).to_f
	energy = bats.map {|b| IO.read("#{b}/energy_full").to_i }.inject(:+).to_f - energy if ac
	$stderr.puts energy
	$stderr.puts power
	run_out = DateTime.now + (energy/power/24)
	hours = (energy / power)
	"#{hours.to_i}h#{((hours*60)%60).to_i}m"
	#hours.round(1).to_s
	#run_out.strftime '%H:%M'
end

def get_output_string
	stuff = []
	stuff << { name: :disk_info, instance: '/', color: '#666666', full_text: disk_space }
	stuff << { name: :mem_info, color: '#666666', full_text: memory_space }
	stuff.last.merge!({separator: true})

	if `rfkill list bluetooth`.include? 'yes'
		stuff << ({name: :bluetooth, instance: :disabled, color: '#444444', full_text: 'BT'})
	else
		stuff << ({name: :bluetooth, instance: :enabled, color: '#6677cc', full_text: 'BT'})
	end
	stuff << ( { name: :ethernet, instance: 'tun0', color: '#ffff00', full_text: "VPN: #{eth_pretty 'tun0'}" } rescue { name: :ethernet, instance: 'tun0', color: '#444444', full_text: 'VPN: down' } )
	stuff << ( { name: :ethernet, instance: 'enp0s25', color: '#6677cc', full_text: "E: #{eth_pretty 'enp0s25'}" } rescue { name: :ethernet, instance: 'enp0s25', color: '#880000', full_text: 'E: down' } )
	begin
		wlan = wlan_pretty 'wlp3s0'
		stuff <<  { name: :wireless, instance: 'wlp3s0', color: (wlan=='off' ? '#444444' : '#6677cc'), full_text: "W: #{wlan}" }
	rescue
		stuff << { name: :wireless, instance: 'wlp3s0', color: '#880000', full_text: 'W: down' }
	end
	stuff.last.merge!({separator: true})

	stuff << battery_stuff('BAT0', 'int')
	stuff << battery_stuff('BAT1', 'ext')
	stuff << {name: :battery_summary, full_text: battery_summary } rescue nil
	stuff.last.merge!({separator: true})

	stuff << { name: :load, full_text: get_load_1m }
	stuff.last.merge!({separator: true})

	stuff << { name: :brightness, full_text: "â˜¼ #{get_brightness_percent}%" }
	volicon = case
		when (@cached_volume_percent.include? 'Headphones') then 'ðŸŽ§' + ((@cached_volume_percent.include? 'Mute') ? "\u0338" : '')
		when @cached_volume_percent.to_i > 50 then 'ðŸ”Š'
		when @cached_volume_percent.to_i > 0 && !(@cached_volume_percent.include? 'Mute') then 'ðŸ”‰'
		else 'ðŸ”‡'
	end
	stuff << { name: :volume, full_text: "#{volicon} #{@cached_volume_percent.split("\n")[0]}" }
	stuff.last.merge!({separator: true})
	stuff.last.merge!({color: '#dd8800'}) if @cached_volume_percent.include? 'Mute'

	stuff << { name: :tztime, instance: :local, full_text: date_pretty }

	stuff.each do |item|
		if item[:separator]
			item[:separator_block_width] = 27
		else
			item[:separator] = false
			item[:separator_block_width] = 13
		end
	end

	return JSON.generate(stuff)
end

@cached_volume_percent = get_volume_percent

Thread.abort_on_exception = true

redraw = Thread.new do
	$stdout.syswrite "{\"version\":1, \"click_events\":true}\n"
	$stdout.syswrite "[\n"
	first = true
	loop do
		$stdout.syswrite "#{first ? '' : ','}#{get_output_string}\n"
		first = false
		t = Time.now
		sleep (5 - (t.sec + t.subsec) % 5)
	end
end

receive_click_events = Thread.new do
loop do
	begin
		click = $stdin.gets
		click = click[1..-1] if click.start_with? ','
		$stderr.puts click
		click = JSON.parse(click)

		if click['button'] == 3 && (click['name'] == 'wireless' || click['name'] == 'ethernet')
			p = Process.spawn("echo #{get_ip click['instance']} | xclip -selection clipboard || true")
			Process.detach(p)
		elsif click['button'] == 1 && click['name'] == 'bluetooth'
			$stderr.puts("/usr/sbin/rfkill #{click['instance']!='enabled' ? 'un' : ''}block bluetooth")
			p = Process.spawn("/usr/sbin/rfkill #{click['instance']!='enabled' ? 'un' : ''}block bluetooth")
			Process.detach(p)
		elsif click['button'] == 1 && click['name'] == 'tztime'
			p = Process.spawn(%q{gnome-terminal --geometry='70x10' --title='Calendar' --role=calendar -e 'bash -c "echo -ne \"\\033]0;Calendar\\007\"; cal -3; read -n 1"'})
			Process.detach(p)
		elsif click['button'] == 3 && click['name'] == 'tztime'
			now = DateTime.now.new_offset(0)
			p = Process.spawn("echo #{now.strftime('%Y-%m-%dT%H:%M:%SZ')} | xclip -selection clipboard || true")
			Process.detach(p)
		end
	rescue
	end
end
end

Signal.trap 'USR1' do
	redraw.run
end

loop do
	ev = dbus_events.gets
	case ev.chomp
		when 'volume', 'mute'
			@cached_volume_percent = get_volume_percent
			redraw.run
	end
end

receive_click_events.join
redraw.join
