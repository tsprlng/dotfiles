#!/usr/bin/env ruby

require 'date'
require 'dbus'
require 'json'


dbus_events, dbus_event_sender = IO.pipe
dbus_watcher = fork do
	dbus_events.close
	session_bus = DBus.session_bus
	pasockaddr = session_bus['org.PulseAudio1']['/org/pulseaudio/server_lookup1']['org.PulseAudio.ServerLookup1']['Address']

	retried = false
	begin
		pa = DBus::Connection.new(pasockaddr)
	rescue
		raise if retried
		retried = true
		STDERR.puts 'Loading pulseaudio dbus module'
		`pactl load-module module-dbus-protocol`
		sleep 1
		retry
	end
	core = pa['org.PulseAudio1.Core1']['/org/pulseaudio/core1']
	core.default_iface = 'org.PulseAudio.Core1'

	core.ListenForSignal('org.PulseAudio.Core1.Device.MuteUpdated', [])
	core.ListenForSignal('org.PulseAudio.Core1.Device.VolumeUpdated', [])

	match_rule = DBus::MatchRule.new
	match_rule.member = 'MuteUpdated'
	match_rule.interface = 'org.PulseAudio.Core1.Device'

	pa.add_match(match_rule) do |state|
		dbus_event_sender.puts 'mute' if state.path.include? 'sink'
	end

	match_rule = DBus::MatchRule.new
	match_rule.member = 'VolumeUpdated'
	match_rule.interface = 'org.PulseAudio.Core1.Device'

	pa.add_match(match_rule) do |state|
		dbus_event_sender.puts 'volume' if state.path.include? 'sink'
	end

	loop = DBus::Main.new
	loop << pa
	loop.run
end
dbus_event_sender.close

def get_brightness_percent
	curr = IO.read '/sys/class/backlight/intel_backlight/actual_brightness'
	max = IO.read '/sys/class/backlight/intel_backlight/max_brightness'
	(curr.to_f * 100/ max.to_f).round
end

def get_volume_percent
	`volume show`.chomp.chomp('%')  # TODO replace this shit with DBus query
end

def date_pretty
	now = DateTime.now  #.new_offset(0)
	#return DateTime.now.new_offset(0).iso8601.sub '+00:00', 'Z'
	case now.offset
	when 0
		now.strftime '%Y-%m-%d %H:%M:%S'
	else
		now.strftime '%Y-%m-%d "%H:%M:%S"'
	end
end

def get_load_1m
	loads = IO.read '/proc/loadavg'
	loads.split(' ',2)[0]
end

def wlan_pretty
	ips = `ip -o -f inet addr show primary up`
	ipline = ips.each_line  .select {|l| l.match /^\d+: wlp3s0/} .first
	ip = (ipline.split(' inet ',2)[1]).split('/',2)[0]

	wstat = IO.read '/proc/net/wireless'
	stats = wstat.each_line .select {|l| l.match /^wlp3s0/} .first .split /\s+/
	"#{stats[3].chomp('.')}dB #{stats[5..10].map(&:to_i).inject(:+)}! #{ip}"
end

def eth_pretty
	ips = `ip -o -f inet addr show primary up`
	ipline = ips.each_line  .select {|l| l.match /^\d+: enp0s25/} .first
	ip = (ipline.split(' inet ',2)[1]).split('/',2)[0]
end

def disk_space
	`df -h /`.lines()[1].split(/\s+/)[3]
end

def memory_space
	meminfo = IO.read '/proc/meminfo' .lines.to_a
end

def battery_stuff(whichbat, label)
	designed_cap = IO.read("/sys/class/power_supply/#{whichbat}/energy_full_design").chomp.to_f
	actual_cap = IO.read("/sys/class/power_supply/#{whichbat}/energy_full").chomp.to_f
	current = IO.read("/sys/class/power_supply/#{whichbat}/energy_now").chomp.to_f
	status = IO.read("/sys/class/power_supply/#{whichbat}/status").chomp

	percent = (100 * current / designed_cap).round(1)

	color = case
		when percent <= 5 then '#ff0000'
		when (status == 'Full' || status == 'Unknown') && current >= (actual_cap * 0.97) then '#009900'
		when (status == 'Charging' || status == 'Unknown') then '#dddd00'
		else '#999999'
	end

	{ name: :battery, instance: whichbat, color: color, full_text: "#{label} #{percent}" }
end

def get_output_string
	stuff = []
	stuff << { name: :disk_info, instance: '/', full_text: disk_space }
	stuff << ( { name: :ethernet, instance: 'enp0s25', color: '#6677cc', full_text: "E: #{eth_pretty}" } rescue { name: :ethernet, instance: 'enp0s25', color: '#880000', full_text: 'E: down' } )
	stuff << ( { name: :wireless, instance: 'wlp3s0', color: '#6677cc', full_text: "W: #{wlan_pretty}" } rescue { name: :wireless, instance: 'wlp3s0', color: '#880000', full_text: 'W: down' } )
	stuff << battery_stuff('BAT0', 'int')
	stuff << battery_stuff('BAT1', 'ext')
	stuff << { name: :load, full_text: get_load_1m }
	stuff << { name: :brightness, full_text: "â˜¼ #{get_brightness_percent}%" }
	volicon = case
		when @cached_volume_percent.to_i > 50 then 'ðŸ”Š'
		when @cached_volume_percent.to_i > 0 then 'ðŸ”‰'
		else 'ðŸ”‡'
	end
	stuff << { name: :volume, full_text: "#{volicon} #{@cached_volume_percent}" }
	stuff << { name: :tztime, instance: :local, full_text: date_pretty }
	return JSON.generate(stuff)
end

@cached_volume_percent = get_volume_percent

Thread.abort_on_exception = true
first = true
draw = Thread.new do
	$stdout.syswrite "{\"version\":1, \"click_events\":true}\n"
	$stdout.syswrite "[\n"
	while 1
		$stdout.syswrite "#{first ? '' : ','}#{get_output_string}\n"
		first = false
		t = Time.now
		sleep ((5 - t.sec - t.subsec) % 5)
	end
end

clicks = Thread.new do
while 1
	begin
		click = $stdin.gets
		if click.start_with? ','
			click = JSON.parse(click[1..-1])
		elsif click.start_with? '{'
			click = JSON.parse(click)
		end
		if click['button'] == 3 && (click['name'] == 'wireless' || click['name'] == 'ethernet')
			ips = `ip -o -f inet addr show primary up`
			ipline = ips.each_line  .select {|l| l.match /^\d+: #{click['instance']}/} .first
			ip = (ipline.split(' inet ',2)[1]).split('/',2)[0]
			p = Process.spawn("echo #{ip} | xclip -selection clipboard || true")
			Process.detach(p)
		elsif click['button'] == 3 && click['name'] == 'tztime'
			now = DateTime.now.new_offset(0)
			p = Process.spawn("echo #{now.strftime('%Y-%m-%dT%H:%M:%SZ')} | xclip -selection clipboard || true")
			Process.detach(p)
		end
	rescue
	end
end
end

Signal.trap 'USR1' do
	draw.run
end

while 1
	ev = dbus_events.gets
	case ev.chomp
		when 'volume', 'mute'
			@cached_volume_percent = get_volume_percent
			draw.run
	end
end

clicks.join
draw.join
Process.kill('TERM', dbus_watcher) rescue nil  # rescue because what if it's already dead TODO is this good?
Process.wait(dbus_watcher)
