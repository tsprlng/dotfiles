#!/usr/bin/env ruby

require 'docopt'
require 'ruby_expect'
require 'stringio'

Usage = <<USAGE
Usage:
  #{__FILE__}
  #{__FILE__} add <description> (tcp|udp|all) <external-port> <internal-host> [internal-port]
  #{__FILE__} del <external-port-or-description>
  #{__FILE__} -h | --help
USAGE

class ActionType < Struct; end
Show = ActionType.new(:_)
Add = ActionType.new(:description, :protocol, :externalPort, :internalHost, :internalPort)
Delete = ActionType.new(:searchString)

begin
	Args = Docopt::docopt(Usage)
	case
	when Args['add']
		stuff = [
			Args['<description>'],
			Args['tcp'] ? :TCP : Args['udp'] ? :UDP : Args['all'] ? :ALL : raise,
			Args['<external-port>'].to_i,
			Args['<internal-host>'],
			(Args['internal-port'] || Args['<external-port>']).to_i,
		]
		Action = Add.new(*stuff)
	when Args['del']
		Action = Delete.new(Args['<external-port-or-description>'])
	else
		Action = Show.new
	end
rescue
	#puts $!
	$stderr.puts Usage
	exit 1
end

p Args if $debug
p Action if $debug

def get_password
	$stderr.puts "Awaiting password..."
	`pass zyxel-router-admin`.rstrip
end

RouterIp = '192.168.1.1'
Username = 'admin'
Password = get_password
WanInterface = 'Plusnet'

$debug = false
$logger = Logger.new($stderr)

def bin_bool(bin)
	case bin
	when 0,'0','',nil
		false
	else
		true
	end
end
def na_null(str)
	case str
	when 'N/A','',nil
		nil
	else
		str
	end
end
def parse_nat_get_lines(lines)
	_fields = {
		index: ['Index', :to_i],
		description: ['Description'],
		enabled: ['Enable', Proc.new{|b| bin_bool(b)}],
		remote_ip: ['Originating IP', Proc.new{|s| na_null(s)}],
		local_ip: 'Server IP Address',
		wan_interface: 'WAN Interface',
		remote_start_port: ['Start Port', :to_i],
		remote_end_port: ['End Port', :to_i],
		local_start_port: ['Translation Start Port', :to_i],
		local_end_port: ['Translation End Port', :to_i],
		protocol: 'Protocol',  # TCP|UDP|ALL
	}
	field_matchers = []
	_fields.each do |name, matcher|
		col_label, mapping = matcher
		start_pos = lines.first.index(col_label)
		(field_matchers[-1][:end_pos] = start_pos-1) rescue nil
		field_matchers << {name: name, start_pos: start_pos, end_pos: -1, mapping: mapping}
	end
	lines[1..-1].map{ |l|
		data = {}
		field_matchers.each do |matcher|
			data[matcher[:name]] = (matcher[:mapping] || :itself).to_proc.call(l[matcher[:start_pos]..matcher[:end_pos]].rstrip)
		end
		data
	}.to_a
end
def format_port_range(start, stop)
	case
	when start==stop
		start.to_s
	else
		"[#{start}..#{stop}]"
	end
end
def format_nat_line(data)
	line = StringIO.new
	data[:remote_ip].nil? or raise "remote_ip is set"
	data[:wan_interface]==WanInterface or raise "wan_interface is weird"
	line << data[:index].to_s.rjust(2) << ' '
	line << (data[:enabled] ? 'âˆš' : 'X') << ' '
	line << data[:description].ljust(32) << ' '
	line << data[:protocol] << ' '
	line << format_port_range(data[:remote_start_port], data[:remote_end_port])
	line << ' -> ' << data[:local_ip] << ' '
	line << format_port_range(data[:local_start_port], data[:local_end_port])
	line.string
end

telnet = RubyExpect::Expect.spawn("telnet #{RouterIp}", $debug ? {debug: true, logger: $logger} : {})
telnet.procedure do
	each do
		expect 'VMG1312-B10D login: ' do
			send Username
		end
		expect 'Password: ' do
			send Password
		end
	end

	case Action
	when Show
		each do
			expect 'ZySH> ' do
				send 'cfg nat get'
			end
			expect 'ZySH> ' do
				parse_nat_get_lines(before.lines[1..-2]).each do |nat|
					puts format_nat_line(nat)
				end
			end
		end
	when Add
		each do
			expect 'ZySH> ' do
				send [
					"cfg nat add --Enable 1",
					"--Description #{Action[:description]}",
					"--Interface #{WanInterface}",
					"--ExternalPortStart #{Action[:externalPort]} --ExternalPortEnd #{Action[:externalPort]}",
					"--InternalPortStart #{Action[:internalPort]} --InternalPortEnd #{Action[:internalPort]}",
					"--InternalClient #{Action[:internalHost]}",
					"--SetOriginatingIP 0",
					"--Protocol #{Action[:protocol]}",
				].join(' ')
			end
			expect 'ZySH> ' do
				puts before.lines
			end
		end
	when Delete
		each do
			expect 'ZySH> ' do
				send 'cfg nat get'
			end
			expect 'ZySH> ' do
				index = nil
				parse_nat_get_lines(before.lines[1..-2]).each do |nat|
					if nat[:remote_start_port]==Action[:searchString].to_i or nat[:description]==Action[:searchString]
						index = nat[:index]
						break
					end
				end
				unless index
					$stderr.puts "Couldn't find \"#{Action[:searchString]}\" forward to delete"
					exit 4
				end
				send "cfg nat delete --Index #{index}"
			end
			expect 'ZySH> ' do
				puts before.lines
			end
		end
	end
end
#telnet.interact
